use XML;
use XML::Text;
use XML::Element;

constant PRELUDE = q:to/EOF/;
# automatically generated by tiger.raku; do not edit
unit module Glarkum;
use NativeCall;
sub SDL_GL_GetProcAddress(Str --> Pointer) is native('SDL2') {*}
constant c_uchar = uint8;
constant c_ushort = uint16;
constant c_int = int32;
constant c_uint = uint32;

constant GLenum is export = c_uint;
constant GLboolean is export = c_uchar;
constant GLbitfield is export = c_uint;
constant GLbyte is export = int8;
constant GLubyte is export = uint8;
constant GLshort is export = int16;
constant GLushort is export = uint16;
constant GLint is export = c_int;
constant GLuint is export = c_uint;
constant GLclampx is export = int32;
constant GLsizei is export = c_int;
constant GLfloat is export = num32;
constant GLclampf is export = num32;
constant GLdouble is export = num64;
constant GLclampd is export = num64;
class GLeglClientBufferEXT is repr('CPointer') is export {}
class GLeglImageOES is repr('CPointer') is export {}
#GLchar
#GLcharARB
constant GLhandleARB = $*DISTRO.name eq 'macosx' ?? Pointer !! c_uint;

constant GLhalf is export = uint16;
constant GLhalfARB is export = uint16;
constant GLfixed is export = int32;
constant GLintptr is export = size_t; #actually intptr_t
constant GLintptrARB is export = size_t; #actually intptr_t
constant GLsizeiptr is export = ssize_t;
constant GLsizeiptrARB is export = ssize_t;
constant GLint64 is export = int64;
constant GLint64EXT is export = int64;
constant GLuint64 is export = uint64;
constant GLuint64EXT is export = uint64;
class GLsync is repr('CPointer') is export {}
# compiler apparently doesn't like these
#constant GLDEBUGPROC    is export = :(GLenum $source, GLenum $type, GLuint $id, GLenum $severity, GLsizei $length, Str $message, Pointer $userParam);
#constant GLDEBUGPROCARB is export = :(GLenum $source, GLenum $type, GLuint $id, GLenum $severity, GLsizei $length, Str $message, Pointer $userParam);
#constant GLDEBUGPROCKHR is export = :(GLenum $source, GLenum $type, GLuint $id, GLenum $severity, GLsizei $length, Str $message, Pointer $userParam);

#constant GLDEBUGPROCAMD is export = :(GLuint $id, GLenum $category, GLenum $severity, GLsizei $length, Str $message, Pointer $userParam);
constant GLhalfNV is export = c_ushort;
constant GLvdpauSurfaceNV is export = GLintptr;
#constant GLVULKANPROCNV is export = :();
EOF

my @bad-types = <GLDEBUGPROC GLDEBUGPROCARB GLDEBUGPROCKHR GLDEBUGPROCAMD GLVULKANPROCNV>;

sub time($what) {
	state $time = now;
	my $new-time = now;
	printf "$what (%.2fs).\n", $new-time - $time;
	$time = $new-time;
}

time "Started up";
# gumbo from-html is 30% slower
#my $tree = from-xml(slurp 'abbrev.xml'); #opengl-registry/xml/gl.xm
my $tree = from-xml(slurp 'opengl-registry/xml/gl.xml');
time "Loaded OpenGL XML specification";

# todo separate by version
my SetHash $enums .= new;
my SetHash $commands .= new;

for $tree.elements(:TAG<feature> :api<gl>) {
	for $_.elements(:TAG<require>) {
		for $_.elements(:TAG<enum>) { $enums.set($_.attribs<name>) }
		for $_.elements(:TAG<command>) { $commands.set($_.attribs<name>) }
	}
}

time "Calculated features list";

my $fp = 'glarkum.rakumod'.IO.open: :w;
LEAVE $fp.close;
$fp.write(PRELUDE.encode);

for $tree.elements(:TAG<enums>) -> $enum {
	my $name = $enum.attribs<group> // "";
	my @values = $enum.elements(:TAG<enum>).map: {$_.attribs<name> ∈ $enums ?? ($_.attribs<name>, $_.attribs<value>) !! Empty};
	for @values { $fp.write: "constant $_[0] is export = $_[1];\n".encode; }
	#if @values { $fp.write: ("enum $name" ~ "({@values.map({"$_[0] => $_[1]"}).join: ', '});\n").encode }
}

time "Wrote enums";

class Type {
	has Str $.name is rw;
	has Int $.pointer is rw = 0;
}
class Command {
	has Type $.ret;
	has Str $.name;
	has @.params;
}

class Struct is Exception {};

sub parse-type($xml) {
	my Str $name;
	my Type $type .= new;

	sub add-text($text) {
		for $text.words {
			given $_ {
				when '*'|'*const'|'const*' { $type.pointer++ }
				when '*const*'|'**' { $type.pointer += 2 }
				when 'const'|'' {}
				when 'struct' { Struct.new.throw }
				default { die "{$type.name}|$_|$xml" if $type.name; $type.name = $_ }
			}
		}
	}

	for $xml.nodes -> $p {
		given $p {
			when XML::Text { add-text $p.text }
			when XML::Element {
				if $p.name eq 'name' {
					die if $name;
					$name = $p[0].text;
				} else {
					add-text $p[0].text;
				}
			}
			default { die "malformed type" }
		}
	}
	die "$xml" unless $name && $type.name;
	$type,$name;
}

my @commands = do for $tree.elements(:TAG<commands>, :namespace<GL>)[0].elements(:TAG<command>) -> $command {
	my ($ret, $name);
       	try { ($ret, $name) = parse-type $command.elements(:TAG<proto>)[0] };

	next if $! ~~ Struct; $!.throw if $!;

	my @params;
       	try {
		@params = do for $command.elements(:TAG<param>) -> $param {
			parse-type $param;
		}
	}
	next if $! ~~ Struct; $!.throw if $!;
	Command.new(:$ret, :$name, :@params);
}

for @commands -> $command {
	$fp.write: "our &{$command.name} is export;\n".encode;
}

$fp.write: "sub load-gl-procs is export \{\n".encode;
for @commands -> $command {
	#say $command;
	sub type-to-string(Type $t) {
		my $ret = $t.name;
		my $tp = $t.pointer;
		next if $ret ∈ @bad-types;
		if $ret eq 'GLchar'|'GLcharARB' && $tp { $ret = 'Str'; $tp-- }
		for ^$tp { if $ret eq 'void' { $ret = 'Pointer' } else { $ret = "CArray[$ret]" } };
		$ret
	}
	my $signature-params = $command.params.map({type-to-string($_[0]) ~ " \$$_[1]"}).join(', ');
	my $return = type-to-string $command.ret;
	if $command.name eq 'glGetString'|'glGetStringi' { $return = "Str" } #https://github.com/KhronosGroup/OpenGL-Registry/issues/363
	my $return-string = $return eq 'void' ?? '' !! " --> $return";
	$fp.write: "\t&{$command.name} = nativecast(:($signature-params$return-string), SDL_GL_GetProcAddress('{$command.name}')) or return False;\n".encode;
}
$fp.write: "\}\n".encode;

time "Wrote command names"
